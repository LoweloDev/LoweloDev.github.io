"use strict";

var _interopRequireWildcard = require("@babel/runtime/helpers/interopRequireWildcard");

var _interopRequireDefault = require("@babel/runtime/helpers/interopRequireDefault");

var _extends2 = _interopRequireDefault(require("@babel/runtime/helpers/extends"));

var _react = _interopRequireWildcard(require("react"));

require("jest-dom/extend-expect");

var _ = require("../");

afterEach(_.cleanup);
test('testHook calls the callback', () => {
  const spy = jest.fn();
  (0, _.testHook)(spy);
  expect(spy).toHaveBeenCalledTimes(1);
});
test('confirm we can safely call a React Hook from within the callback', () => {
  (0, _.testHook)(() => (0, _react.useState)());
});
test('returns a function to unmount component', () => {
  let isMounted;
  const {
    unmount
  } = (0, _.testHook)(() => {
    (0, _react.useEffect)(() => {
      isMounted = true;
      return () => {
        isMounted = false;
      };
    });
  });
  expect(isMounted).toBe(true);
  unmount();
  expect(isMounted).toBe(false);
});
test('returns a function to rerender component', () => {
  let renderCount = 0;
  const {
    rerender
  } = (0, _.testHook)(() => {
    (0, _react.useEffect)(() => {
      renderCount++;
    });
  });
  expect(renderCount).toBe(1);
  rerender();
  expect(renderCount).toBe(2);
});
test('accepts wrapper option to wrap rendered hook with', () => {
  const ctxA = _react.default.createContext();

  const ctxB = _react.default.createContext();

  const useHook = () => {
    return _react.default.useContext(ctxA) * _react.default.useContext(ctxB);
  };

  let actual;
  (0, _.testHook)(() => {
    actual = useHook();
  }, {
    // eslint-disable-next-line react/display-name
    wrapper: props => _react.default.createElement(ctxA.Provider, {
      value: 3
    }, _react.default.createElement(ctxB.Provider, (0, _extends2.default)({
      value: 4
    }, props)))
  });
  expect(actual).toBe(12);
});
test('returns result ref with latest result from hook execution', () => {
  const {
    result
  } = (0, _.testHook)(function ({
    initialCount = 0,
    step = 1
  } = {}) {
    const [count, setCount] = _react.default.useState(initialCount);

    return {
      count,
      increment: () => setCount(c => c + step),
      decrement: () => setCount(c => c - step)
    };
  });
  expect(result.current.count).toBe(0);
  (0, _.act)(() => {
    result.current.increment();
  });
  expect(result.current.count).toBe(1);
});